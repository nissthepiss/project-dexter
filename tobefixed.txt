================================================================================
PROJECT DEXTER - POTENTIAL BUGS, ERRORS, AND DATA INCONSISTENCIES
Analysis Date: 2026-01-21
Iteration: 3/5
================================================================================

================================================================================
ADDITIONAL FINDINGS FROM ITERATION 3
================================================================================

================================================================================
CRITICAL ISSUES
================================================================================

1. [SECURITY] Hardcoded Telegram Credentials (telegramService.mjs:13-20)
   - API_ID, API_HASH, PHONE, CHANNEL_IDS are hardcoded in source
   - This is a security vulnerability if code is shared/deployed
   - Should use environment variables

2. [DATA LOSS] Database Shadow Files Not Handled (db.mjs:377-463)
   - When purging database, .shm and .wal files are deleted
   - But saveDatabase() is called BEFORE file deletion, then db recreated
   - This could cause data persistence issues
   - The saveDatabase() call at line 408 may write data that gets immediately deleted

3. [RACE CONDITION] Token Discovery Duplicate Prevention (tokenManager.mjs:783-790)
   - Lines 783-790: "Guard: never overwrite spottedAt for existing tokens"
   - This check happens AFTER token is already added to trackedTokens in discovery
   - Race condition: if same token discovered twice quickly, first spottedAt could be overwritten
   - The check at line 785 `if (this.trackedTokens.has(addr))` comes AFTER batch API call

4. [MEMORY LEAK] Failed Discovery Tokens Never Cleaned Up (tokenManager.mjs:48)
   - failedDiscoveryTokens Map grows indefinitely
   - Tokens that fail discovery are tracked with retry logic
   - But old entries (beyond retry window) are never removed from the Map
   - This will cause memory growth over time

5. [INCONSISTENT DATA] Peak Multiplier Calculation (tokenManager.mjs:147)
   - `peakMc: tokenData.peakMultiplier * tokenData.spottedMc`
   - Assumes peakMultiplier is already calculated correctly in DB
   - If spottedMc changed but peakMultiplier not updated, this gives wrong peakMc
   - Should store peakMc directly in DB instead of recalculating

================================================================================
HIGH PRIORITY BUGS
================================================================================

6. [LOGIC ERROR] View Mode '2h' Not Handled in MVP Calculator (mvpCalculator_v3.mjs:255-305)
   - Case '2h' is missing from switch statement in adjustWeightsForViewMode()
   - Falls through to default 'all-time' weights
   - But tokenManager.getTop10() supports '2h' mode (line 1111)
   - This causes incorrect scoring for 2h view mode

7. [UNHANDLED ERROR] SSE Connection Errors (dexpaprika.mjs:120-122)
   - SSE 'error' event only logs to debug level
   - No reconnection logic for failed SSE connections
   - If SSE stream fails, token stays in sseConnectedTokens but has no live updates
   - Should either: disconnect token on error, or attempt reconnection

8. [DATA INCONSISTENCY] Volume Sanity Check Too Broad (tokenManager.mjs:461-465)
   - Rejects data if volume > 1000x MC
   - But what if legitimate high-volume token? (e.g., 1000x volume is possible)
   - This could reject valid data for volatile tokens
   - Should use higher threshold or additional validation

9. [NULL REFERENCE] Token Routes Stats Endpoint (tokenRoutes.mjs:156-161)
   - `tokenManager.topTokens.length` - topTokens property doesn't exist on TokenManager
   - `tokenManager.fadeOutTokens.length` - fadeOutTokens property doesn't exist
   - This will throw "Cannot read property 'length' of undefined"
   - These properties were removed/refactored but endpoint not updated

10. [POTENTIAL DIVIDE BY ZERO] MVP Calculator (mvpCalculator_v3.mjs:219-220)
    - `const currentMultiplier = token.currentMc / token.spottedMc;`
    - If spottedMc is 0, this returns Infinity
    - Happens for holder tokens added without initial data (spottedMc=0)
    - Should guard against spottedMc <= 0

================================================================================
MEDIUM PRIORITY ISSUES
================================================================================

11. [STALE DATA] Metrics Freshness Check May Be Too Strict (mvpCalculator_v3.mjs:241-248)
    - 30 second freshness window for transaction metrics
    - If metrics update fails once, token scores drop significantly
    - No graceful degradation - just loses those components entirely
    - Consider longer window or partial score fallback

12. [INCONSISTENT BEHAVIOR] Holder Token SpottedMc Initialization (tokenManager.mjs:481-490)
    - Holder tokens can have spottedMc=0 when first added
    - Then later initialized from DexPaprika data
    - But initial multiplier calculations will use 0 as baseline
    - This creates misleading multipliers until data arrives

13. [RACE CONDITION] View Mode Debounce (tokenManager.mjs:1198-1208)
    - 2 second debounce when view mode changes
    - But updateSSESubscriptions() checks `if (this.viewModeDebounceTimer)` (line 308)
    - During debounce, SSE updates are completely blocked
    - This means top 10 won't update for 2 seconds after mode change
    - Could cause stale data display

14. [DATA INCONSISTENCY] Ten Second Snapshot Not Initialized (tokenManager.mjs:344-352)
    - `_tenSecondSnapshotAt` can be null initially
    - But then the check `>= 10000` will never be true if it stays null
    - Wait - there IS initialization check: `if (token._tenSecondSnapshotAt === null)`
    - However, this only runs in handleSSEPriceUpdate() and updateBackgroundTokensDexPaprika()
    - If token is never updated via these paths, snapshot never initializes

15. [ERROR HANDLING] Holder Service Token Add Failure (holderService.mjs:121-145)
    - When adding holder tokens, if tokenManager.addHolderToken() fails
    - The error is caught but token is not marked as needing retry
    - Failed holder tokens are never retried
    - Should track failures like discovery does

================================================================================
LOW PRIORITY / CODE QUALITY
================================================================================

16. [INCONSISTENCY] Missing Error Code in Server (server.mjs:572-576)
    - Error handler checks `err.code === 'EADDRINUSE'`
    - But then immediately exits process without graceful shutdown
    - tokenManager.shutdown() is called but errors are ignored
    - Should ensure cleanup completes before exit

17. [POTENTIAL BUG] DexScreener Chain Comparison (dexscreener.mjs:17-18)
    - `token.chainId === 'solana' || token.chain === 'solana'`
    - Inconsistent property access (chainId vs chain)
    - One may be undefined causing incorrect filtering
    - Should use consistent property or provide fallback

18. [DUPLICATE CODE] View Mode Switch in Multiple Places
    - View mode '2h' exists in tokenManager.getViewModeWindowMs() (line 1217)
    - But not in mvpCalculator_v3.adjustWeightsForViewMode()
    - Inconsistent implementation across codebase
    - Should centralize view mode definitions

19. [UNUSED CODE] Disabled Bitquery Functions (tokenManager.mjs:829-995)
    - Large blocks of commented-out code for Bitquery integration
    - Makes code harder to read/maintain
    - Should be removed or moved to separate file

20. [TYPO] Variable Name in Discovery (tokenManager.mjs:712)
    - `const batchSize = 30;`
    - But DexScreener batch API limit is actually 30 tokens per request
    - This is correct, but the loop uses `i += batchSize` which could skip tokens if batch doesn't divide evenly
    - Actually no, the slice handles this correctly
    - However, there's no verification that all tokens in batch were processed

21. [INCONSISTENT NULL HANDLING] Database Token Insert (db.mjs:191-218)
    - Extensive null coalescing with `??` operator
    - But some fields like `spottedAt` default to `Date.now()` if undefined
    - Inconsistent: some use `?? null`, others use `?? defaultValue`
    - Should have consistent strategy for required vs optional fields

22. [POTENTIAL ISSUE] MVP Calculator Momentum Check (mvpCalculator_v3.mjs:54-57)
    - `sseMomentum.blendedMcMomentum * 100`
    - If blendedMcMomentum is negative, this produces negative score contribution
    - This may be intentional (bearish signal) but not documented
    - Also, raw value stored (line 108) would be negative - confusing for display

23. [MISSING VALIDATION] Public Channel URL Extraction (telegramService.mjs:94-122)
    - extractChannelId() tries multiple patterns but returns null if none match
    - No validation that extracted ID is valid (could be random number)
    - Should verify ID format (e.g., negative for channels)

24. [DATA LOSS RISK] Announced Tokens Not Cleaned Up (telegramService.mjs:501-537)
    - announcedTokens Map grows indefinitely
    - Old entries are never removed
    - Should have cleanup for tokens older than X days

25. [INCONSISTENT API] Tier 3 Alert Return Values (telegramService.mjs:361-444)
    - Returns `success: true` even when rate limited (line 405)
    - Also returns `success: true` when messaging is disabled (line 367)
    - This is misleading - "success" should mean "alert sent"
    - Callers can't distinguish between "sent successfully" and "skipped"

================================================================================
FRONTEND ISSUES
================================================================================

26. [MEMORY LEAK] Event Listeners Not Cleaned Up (app.js:89-99, 1000+)
    - Multiple addEventListener calls but no cleanup
    - For example: resize handler at line 269, document click at line 691
    - If app is re-initialized (e.g., hot reload), old listeners persist
    - Should track listeners and remove on cleanup

27. [POTENTIAL ERROR] LocalStorage JSON Parse (app.js:122-148)
    - `JSON.parse(savedState)` without try-catch
    - If localStorage is corrupted, entire terminal positioning fails
    - Should wrap in try-catch

28. [INCONSISTENT STATE] Current Mode Tracking (app.js:4-6)
    - Global variables `currentMode`, `currentViewMode` maintained separately
    - But backend also tracks these in server.mjs (line 25) and tokenManager (line 31)
    - Could get out of sync if frontend state changes but backend update fails
    - No reconciliation mechanism

29. [MISSING VALIDATION] Token Score Display (app.js:593-599)
    - Multiplier alert checks `multiplier >= 3 && multiplier < 4`
    - What if multiplier is exactly 4? Alert missed
    - Should be `multiplier >= 3 && multiplier < 5` for 3x-4.99x range
    - Or separate checks for each milestone

30. [POTENTIAL BUG] Previous Token Data Cleanup (app.js:654-660)
    - Cleans up tokens that left the list
    - But only checks `!currentAddresses.has(key)`
    - If API returns empty/partial list, ALL tokens could be deleted
    - Should have minimum check or only cleanup after confirming new data is valid

31. [INCONSISTENCY] Alert Sound Volume (app.js:39-43)
    - Volume stored in localStorage but applied immediately on construction
    - If saved volume is invalid (e.g., > 100), no validation
    - Should clamp to 0-100 range

32. [MISSING ERROR HANDLING] Fetch Calls (app.js:1000+)
    - Multiple fetch() calls without proper error handling
    - Example: syncTelegramMessagingToBackend() (line 726)
    - Only catches and logs, doesn't show user feedback
    - User may think setting was saved when it actually failed

33. [POTENTIAL ISSUE] Token Source Check (app.js:509-510)
    - `const tokenSource = token.source || 'degen';`
    - But tokens can have source='ex-holder' which is different from 'degen'
    - The ternary below only checks for 'holder'/'ex-holder'
    - This correctly identifies both as 'Holder' list
    - However, 'ex-holder' tokens shouldn't alert as "entered the list" - they were removed

================================================================================
DATABASE ISSUES
================================================================================

34. [PERFORMANCE] Synchronous Database Saves (db.mjs:45-53)
    - saveDatabase() uses writeFileSync - blocks event loop
    - Called frequently (every token update)
    - Could cause performance issues with many tokens
    - Consider debouncing or async writes

35. [SCHEMA ISSUE] Missing Unique Constraint (db.mjs:58-76)
    - contractAddress has UNIQUE constraint
    - But 'id' is PRIMARY KEY and auto-generated uuid
    - If uuid generation collides (unlikely but possible), INSERT OR REPLACE would overwrite wrong token
    - Should rely on contractAddress as natural key

36. [MIGRATION ISSUE] Column Add Logic (db.mjs:78-109)
    - ALTER TABLE commands run every init without checking if already added
    - Wrapped in try-catch so errors are ignored
    - But this means on every startup, attempts to add columns that exist
    - Inefficient and clutters logs

37. [DATA INTEGRITY] Cascade Delete Missing (db.mjs:112-121)
    - priceHistory has FOREIGN KEY to tokens
    - But tokens table has no ON DELETE CASCADE
    - When token deleted, orphaned priceHistory records remain
    - Should add CASCADE or manually cleanup

38. [INCONSISTENT DEFAULTS] Alert Tiers (db.mjs:156-164)
    - Default tiers: 1.1, 1.25, 1.4
    - But tokenManager constructor uses: 1.1, 1.2, 1.3 (lines 17-20)
    - Mismatch between DB default and code default
    - New installations get DB defaults, not code defaults

================================================================================
API INTEGRATION ISSUES
================================================================================

39. [TIMEOUT] DexScreener Timeout Too Short (dexscreener.mjs:41, 93)
    - 15 second timeout for token requests
    - For batch requests with 30 tokens, this may not be enough
    - First request in batch could time out before response arrives
    - Should consider longer timeout or individual request timeouts

40. [NO RETRY] API Failures (dexpaprika.mjs:318-346)
    - getTokenData() returns null on error
    - No retry logic for transient failures
    - Caller must handle null, but no distinction between:
       - Network error (retryable)
       - 404 not found (not retryable)
       - 429 rate limited (retry with backoff)

41. [MISSING VALIDATION] API Response Data (tokenManager.mjs:776-781)
    - `const mc = bestPair.marketCap || bestPair.fdv;`
    - If both are undefined/0, token is created with mc=0
    - Then line 777 checks `if (!mc || mc === 0)` - but this is AFTER token added
    - Failed discovery tracking at line 779 happens too late
    - Token already in discovery list with bad data

42. [RATE LIMITING] DexScreener Profiles API (tokenManager.mjs:241-244)
    - Discovery runs every 1 second (60 req/min)
    - DexScreener rate limit is 60 req/min
    - No buffer for:
       - Network delays
       - Other concurrent DexScreener calls (holder token fetches, logo fetches)
    - Could exceed rate limit and get blocked

================================================================================
SSM (SSE) ISSUES
================================================================================

43. [CONNECTION LEAK] SSE Disconnection (dexpaprika.mjs:142-152)
    - disconnect() destroys request but doesn't remove from failedConnections
    - Tokens in backoff stay in failedConnections forever
    - If token disconnects and reconnects successfully, should clear backoff state
    - Currently backoff cleared on connect (line 49) but what if was previously in backoff?

44. [MISSING HEARTBEAT] SSE Connection Health (dexpaprika.mjs)
    - No heartbeat/ping mechanism to detect dead connections
    - If server stops sending data but connection stays open, won't detect
    - Relies only on incoming data events
    - Should implement timeout-based health check

45. [QUEUE PROCESSING] SSE Connection Queue (dexpaprika.mjs:154-176)
    - Queued tokens are processed sequentially with 500ms delay
    - If top 10 changes rapidly, queue could backlog
    - Tokens at end of queue wait longer for SSE connection
    - Consider parallel connections with limit

================================================================================
HOLDER MODE ISSUES
================================================================================

46. [DATA INCONSISTENCY] Holder Peak Multiplier (tokenManager.mjs:517-523)
    - Holder peak calculated as: `currentMc / holderSpottedMc`
    - But holderSpottedMc can be 0 for tokens added without data
    - Results in Infinity or NaN
    - Should guard against zero or missing holderSpottedMc

47. [MISSING VALIDATION] Holder Channel CA Extraction (telegramService.mjs:646-674)
    - extractCAFromUrl() has multiple regex patterns
    - No validation that extracted string is valid Solana address
    - Could extract invalid strings that look like addresses
    - Should verify base58 format and length (32-44 chars)

48. [INCONSISTENT UPDATES] Holder Token Background Updates (tokenManager.mjs:410-415)
    - Holder tokens included in background updates regardless of time window
    - But tokens with source='ex-holder' also included
    - Both 'holder' and 'ex-holder' get updates indefinitely
    - Could be many old tokens consuming API quota

================================================================================
ALERT SYSTEM ISSUES
================================================================================

49. [SPAM PREVENTION] Floor Alert Tracking (app.js:569-587)
    - floorAlertedTokens Set tracks tokens that hit 100% drop
    - Tokens removed from tracking when they recover to 50% of peak
    - But what if token drops to 100% again later? Not re-alerted
    - Should reset floor alert after significant recovery

50. [INCONSISTENT COOLDOWN] Alert Cooldowns (app.js:437-460)
    - Different cooldowns for different alert types
    - 'rapid_gain' has 60s cooldown, others have 10s
    - But volume_surge has same 10s cooldown
    - Volume can surge continuously - 10s may cause spam
    - Should be longer or have threshold increase

51. [MISSING RESET] Token Alert History (app.js:463-466, 654-660)
    - History cleaned up when token leaves list
    - But if token stays in list for hours, history accumulates
    - Old entries never expire based on time
    - Should also clean up entries older than X minutes

================================================================================
DOCUMENTATION / METADATA ISSUES
================================================================================

52. [OUTDATED COMMENT] Server Monitoring Window (server.mjs:564)
    - Comment says "Monitoring window: 3 hours"
    - But code uses 2 hours (tokenManager.mjs:28)
    - Misleading comment

53. [INCONSISTENT NAMING] Dexpaprika vs DexPaprika
    - Sometimes "DexPaprika", sometimes "dexpaprika"
    - File is "dexpaprika.mjs" but comments say "DexPaprika"
    - Should be consistent

================================================================================
ADDITIONAL ISSUES FROM ITERATION 2
================================================================================

54. [MEMORY LEAK] DataCollector Buffer Growth (dataCollector.mjs)
    - Accumulates data in this.buffer without size limit
    - Only flushes at 50 items or maxRecordsPerFile
    - Under high load, could consume significant memory
    - Should have max buffer size with forced flush

55. [RACE CONDITION] DataCollector Concurrent Writes (dataCollector.mjs)
    - Multiple calls to recordSnapshot()/recordTop10() can push to buffer concurrently
    - No synchronization mechanism for buffer access
    - Could cause data corruption or lost writes
    - Should use mutex or queue for buffer operations

56. [DATA LOSS] DataCollector Flush Failure (dataCollector.mjs)
    - If fs.writeFileSync() fails in flush(), buffered data is lost
    - No recovery mechanism for failed writes
    - Should implement retry or fallback storage

57. [INFINITE RECURSION] Rate Limit Acquire (rateLimit.mjs)
    - Recursive call `return this.acquire()` could cause stack overflow
    - If rate limiting logic has bugs, recursion never terminates
    - Should use loop instead of recursion

58. [RACE CONDITION] Public Channel Rate Limit (telegramService.mjs:341-349)
    - Multiple concurrent calls to sendTier3Alert() could bypass rate limiting
    - canSendToPublicChannel() and recordPublicSend() not atomic
    - Should use mutex for rate limit check/record

59. [SECURITY] Unprotected Debug Endpoints (debugRoutes.mjs)
    - /purge endpoint can wipe all degen tokens with simple POST
    - No authentication or confirmation required
    - Should require authorization token

60. [TIMEOUT BUG] WithTimeout Function (debugRoutes.mjs)
    - Creates new Promise that rejects, but original promise continues executing
    - Doesn't actually cancel the original operation
    - Should use AbortController for proper timeout

61. [NO VALIDATION] Contract Address Input (debugRoutes.mjs)
    - Test endpoints don't validate contract address format
    - Could pass invalid addresses causing API errors
    - Should validate base58 format and length

62. [MEMORY LEAK] Public Send History (telegramService.mjs:341-353)
    - publicSendHistory array grows over time
    - Only cleaned when canSendToPublicChannel() called
    - If not called, array grows indefinitely
    - Should implement periodic cleanup

63. [RACE CONDITION] Holder Polling Interval (holderService.mjs:23-38)
    - Multiple intervals could be set if startPolling() called concurrently
    - No check if interval already exists before setting new one
    - Should clear existing interval before setting new one

64. [NO VALIDATION] Callback Function (holderService.mjs:94-100)
    - onUpdate callback called without validating it's a function
    - Could throw if onUpdate is not a function
    - Should add typeof check before calling

65. [INCONSISTENT ERROR HANDLING] API Integrations (birdeye.mjs, coingecko.mjs, solscan.mjs, jupiter.mjs)
    - Some use console.warn/error, others should use logger service
    - Makes debugging difficult with inconsistent logging
    - Should standardize on logger service

66. [NO RETRY] API Failures (birdeye.mjs, coingecko.mjs, solscan.mjs, jupiter.mjs)
    - API failures return null/error without retry logic
    - Transient failures cause data loss
    - Should implement exponential backoff retry

67. [MISSING VALIDATION] API Response Data (birdeye.mjs, coingecko.mjs, solscan.mjs, jupiter.mjs)
    - Response validation inconsistent across APIs
    - Some validate, others don't
    - Could cause undefined property access errors
    - Should validate all API responses

68. [HARDCODED TIMEOUTS] API Requests (birdeye.mjs, coingecko.mjs, solscan.mjs, jupiter.mjs)
    - All have fixed 10-second timeouts
    - Not configurable per environment
    - Should use environment variable or config

69. [MISSING USER AGENT] Some API Requests (birdeye.mjs, coingecko.mjs)
    - Some requests don't set User-Agent header
    - API may block requests without User-Agent
    - Should always set User-Agent header

70. [INCONSISTENT] Database Dynamic Imports (channels.mjs, modeRoutes.mjs, blacklistRoutes.mjs)
    - Multiple files import database dynamically on each request
    - Inefficient and could cause initialization issues
    - Should import once at module level

71. [NO VALIDATION] Service Availability (channels.mjs, modeRoutes.mjs, blacklistRoutes.mjs)
    - Routes assume services are available without checking
    - Could crash if service not initialized
    - Should check service exists before using

72. [INCOMPLETE] Error Responses (channels.mjs, modeRoutes.mjs, blacklistRoutes.mjs)
    - Some routes don't include error details in responses
    - Makes debugging difficult for clients
    - Should always return error message and details

73. [NO TRANSACTIONS] Database Operations (db.mjs)
    - Multiple related operations without transaction support
    - Could leave DB in inconsistent state if one fails
    - sql.js doesn't support transactions but should implement compensation logic

74. [FILE LOCKING] Database Access (db.mjs:45-53)
    - No file locking mechanism for database access
    - Multiple processes could corrupt database
    - Should implement file locking or use SQLite with proper locking

75. [MEMORY USAGE] Database Loading (db.mjs:28-35)
    - Loads entire database into memory with sql.js
    - Could be problematic for large datasets
    - Consider migrating to node-sqlite3 for better memory management

76. [MIGRATION RISK] Schema Changes (db.mjs:78-109)
    - Migration code assumes table exists
    - Could fail on concurrent access during migration
    - Should implement proper migration locking

77. [DEPENDENCY SECURITY] Package Versions (package.json)
    - Using specific versions (^1.6.0, ^4.18.2)
    - May miss security updates in dependency tree
    - Should regularly audit and update dependencies

================================================================================
ADDITIONAL ISSUES FROM ITERATION 3
================================================================================

78. [RESOURCE LEAK] DataCollector Buffer Not Cleared (dataCollector.mjs:162-193)
    - flush() clears buffer but doesn't clear if write fails
    - If fs.writeFileSync() throws, buffer retains data
    - Next flush will duplicate data in file
    - Should clear buffer only after successful write

79. [DATA CORRUPTION] DataCollector File Write (dataCollector.mjs:173-185)
    - Reads entire file, appends buffer, writes back
    - If two flushes happen concurrently, data will be lost
    - No file locking for concurrent access
    - Should use append mode or implement locking

80. [POTENTIAL DIVIDE BY ZERO] DataDumper Multiplier (dataDumper.mjs:115)
    - `const currentMultiplier = token.currentMc / token.spottedMc;`
    - If spottedMc is 0, returns Infinity
    - Happens for holder tokens added without data
    - Should guard against zero denominator

81. [MEMORY LEAK] DataDumper Price Snapshots (dataDumper.mjs:35)
    - priceSnapshots Map grows indefinitely
    - Only cleared when token hits 2x
    - Tokens that never hit 2x keep snapshots forever
    - Should implement periodic cleanup

82. [RACE CONDITION] DataDumper TwoX Crossed (dataDumper.mjs:111-113)
    - Check and add to twoxCrossed Set not atomic
    - If two concurrent calls, both could pass check
    - Same token could be dumped twice
    - Should use atomic operation or mutex

83. [NULL REFERENCE] Debug Routes Purge (debugRoutes.mjs:173-174)
    - `tokenManager.topTokens = [];`
    - `tokenManager.fadeOutTokens = [];`
    - These properties don't exist on TokenManager
    - Will throw "Cannot set properties of undefined"
    - Should remove these lines

84. [DATA LOSS] DataCollector Shutdown (dataCollector.mjs:226-232)
    - shutdown() clears interval but doesn't wait for pending flush
    - If flush is in progress, data could be lost
    - Should await flush completion before clearing

85. [POTENTIAL CRASH] Main Process Window State (main/index.js:48-57)
    - `JSON.parse(data)` without try-catch
    - If file is corrupted, app fails to start
    - Should handle parse error gracefully

86. [RESOURCE LEAK] Main Process Backend Spawn (main/index.js:14-29)
    - Backend process spawned but stdio: 'inherit' may not cleanup properly
    - On Windows, uses taskkill but process object not nulled after
    - Multiple start/stop cycles could leak handles
    - Should ensure proper cleanup

87. [TIMING ISSUE] Main Process Backend Startup (main/index.js:134-138)
    - Fixed 2 second wait for backend before creating window
    - If backend takes longer than 2s, window may load before backend ready
    - Should implement health check or proper IPC readiness signal

88. [INCONSISTENT ERROR HANDLING] DataCollector JSON Parse (dataCollector.mjs:176-180)
    - Catches error and sets existingData = []
    - But doesn't log what went wrong
    - Makes debugging file corruption impossible
    - Should log error before clearing

89. [MISSING VALIDATION] Rate Limiter Wait Time (rateLimit.mjs:24-26)
    - `const waitTime = this.windowMs - (now - oldestRequest) + 10;`
    - Adding 10ms buffer but not accounting for clock skew
    - Could wait negative time if system clock changed
    - Should max(waitTime, 0)

90. [MEMORY LEAK] DataCollector Flush Timer (dataCollector.mjs:35-37)
    - setInterval runs forever even if enabled = false
    - flush() checks enabled but timer still consuming resources
    - Should clear interval when disabled

91. [POTENTIAL STALL] Rate Limiter Recursive Acquire (rateLimit.mjs:27)
    - `return this.acquire()` recursive call
    - Under heavy load, could hit max call stack size
    - Confirmed infinite recursion risk
    - Should use async loop instead

92. [DATA INCONSISTENCY] Debug Routes Non-existent Properties (debugRoutes.mjs:173-180)
    - References tokenManager.topTokens and tokenManager.fadeOutTokens
    - These don't exist in TokenManager class
    - purge endpoint will crash when trying to set these
    - Remove lines 173-174 and 176-180

93. [MISSING CLEANUP] Main Process Interval Not Cleared (main/index.js)
    - No clearInterval in stopBackend()
    - If startBackend() called multiple times, multiple intervals created
    - Should track and clear all timers

94. [TYPE COERCION] DataDumper Source Check (dataDumper.mjs:146)
    - `(token.source === 'holder' || token.source === 'ex-holder') ? 'holder' : 'degen'`
    - If source is undefined/null, defaults to 'degen'
    - But tokens might not have source property initialized
    - Should use explicit check for 'degen' source

95. [FILE HANDLE LEAK] Multiple JSON Sync Writes (telegramService.mjs, dataDumper.mjs)
    - Multiple fs.writeFileSync() calls without closing handles
    - Node.js eventually garbage collects but under load could hit OS limit
    - Should use explicit handle management or streaming

96. [POTENTIAL INFINITY] DataDumper SpottedMc Check (dataDumper.mjs:174)
    - `token.spottedMc > 0 ? token.spottedAt : null`
    - Checks spottedMc but spottedAt could be 0/unset
    - Using 0 as falsy but 0 is valid timestamp (Unix epoch)
    - Should use explicit null/undefined check

97. [MISSING ERROR HANDLING] SSE JSON Parse (dexpaprika.mjs:94-95)
    - `const data = JSON.parse(jsonStr);` inside try-catch
    - But catch block is empty (line 112-114)
    - Invalid JSON silently skipped
    - Should log invalid JSON for debugging

98. [RESOURCE LEAK] Interval Timers Not Tracked (tokenManager.mjs)
    - Multiple intervals: discoveryInterval, topUpdateInterval, dexpaprikaBackgroundInterval
    - stopTracking() clears them but if error during clearInterval, others may not clear
    - Should use try-catch for each clearInterval to ensure all cleanup attempted

99. [RACE CONDITION] Token Manager Initialization (server.mjs:41-44)
    - `await tokenManager.initialize()` but if fails, process.exit(1) called
    - No graceful degradation or retry
    - If database is locked, app immediately exits
    - Should implement retry with backoff

100. [MISSING VALIDATION] View Mode Parameter (tokenManager.mjs:1186-1191)
    - Checks if viewMode is in validModes array
    - But if invalid, defaults to 'all-time' and logs warning
    - Frontend may display 'all-time' data while showing different mode
    - Should return error to frontend to fix UI state

================================================================================
UPDATED SUMMARY - ITERATION 3
================================================================================

Total Issues Identified: 100

Severity Breakdown:
- CRITICAL: 7 (added: resource leak in dataCollector)
- HIGH: 18 (added: divide by zero, data corruption, race conditions)
- MEDIUM: 40 (added: timing issues, memory leaks, inconsistent behavior)
- LOW: 28 (added: code quality, error handling)

New Issues in Iteration 3: 23
Most Critical New Issues:
- DataCollector concurrent write data corruption
- DataDumper divide by zero on spottedMc=0
- Debug routes purge accessing non-existent properties
- Main process startup timing issues
- Rate limiter confirmed infinite recursion

Updated Affected Files (with new counts):
1. tokenManager.mjs - 15 issues
2. telegramService.mjs - 12 issues
3. app.js (frontend) - 8 issues
4. db.mjs - 10 issues
5. dataCollector.mjs - 6 issues (NEW: 4)
6. dataDumper.mjs - 5 issues (NEW)
7. debugRoutes.mjs - 5 issues
8. dexpaprika.mjs - 6 issues
9. rateLimit.mjs - 2 issues
10. main/index.js - 4 issues (NEW)
11. Other files - 27 issues

Revised Priority Fixes (Top 5):
1. Fix infinite recursion in rateLimit.acquire() - CONFIRMED STACK OVERFLOW RISK
2. Add mutex for DataCollector buffer access - DATA CORRUPTION RISK
3. Fix debugRoutes purge non-existent properties - CRASH ON PURGE
4. Add spottedMc=0 guards in DataDumper and MVP calculator - INFINITY BUGS
5. Move Telegram credentials to environment variables - SECURITY

================================================================================
